<html>
<head>
	<!-- Cannon barrel textures provided by:
			http://www.flickriver.com/photos/steffen-larsen/tags/textures/
			http://shortformvideo.co.uk/product/texturepak1/
	-->
	<title>Siege Warfare</title>
	<!-- WebGL wrapper library -->
	<script src="js/three.js"></script>
	<!-- Physics Engine -->
	<script src="js/physi.js"></script>
	<!-- Allows for keyboard listeners -->
	<script src="js/threex.keyboardstate.js"></script>
	<!-- Gives user ability to manipulate camera angle -->
	<script src="js/OrbitControls.js"></script>
	<!-- Font used to make scoreboard label, and score -->
	<script src='fonts/helvetiker_regular.typeface.js'></script>
</head>
<body>

<script>
	var camera, scene, renderer;
	var orbControls;
	var groundplane;
	var cannon;
	var ball;
	
	var keyboard;
	
	var balllaunched = false;
	
	Physijs.scripts.worker = 'js/physijs_worker.js';
    Physijs.scripts.ammo = 'ammo.js';
	
	function GenerateGroundPlane()
	{
		var groundTexture = THREE.ImageUtils.loadTexture('assets/groundterrain2.png');
		var groundMaterial = new Physijs.createMaterial(new THREE.MeshLambertMaterial({map:groundTexture}), .4, .8 );
		var groundGeometry = new THREE.PlaneGeometry( 400, 400, 6 );
		ground = new Physijs.BoxMesh( groundGeometry, groundMaterial, 0 );
		scene.add( ground );

		var undergroundTexture = THREE.ImageUtils.loadTexture('assets/undrgrd.png');
		var undergroundMaterial = new THREE.MeshLambertMaterial({map: undergroundTexture});
		var undergroundGeometry = new THREE.BoxGeometry(400, 400, 100);
		var underground = new THREE.Mesh(undergroundGeometry, undergroundMaterial);
		scene.add( underground );
		underground.position.z -= 51;

	}
	
	function GenerateCannon()
	{
		var cylinderTexture = THREE.ImageUtils.loadTexture('assets/barrel-3.png');
		var cylinderGeometry = new THREE.CylinderGeometry( 2, 2, 20, 32 );
		var cylinderMaterial = new THREE.MeshLambertMaterial({map: cylinderTexture});
		var can = new THREE.Mesh( cylinderGeometry, cylinderMaterial );
		can.position.y = -5;

		var loaderGeometry = new THREE.CylinderGeometry( 0.5, 0.5, 2, 32 );
		var loaderMaterial = new THREE.MeshLambertMaterial({map: cylinderTexture});
		var loader = new THREE.Mesh( loaderGeometry, loaderMaterial );
		loader.position.y = 6;

		var firingPinGeometry = new THREE.CylinderGeometry( 0.1, 0.1, 1, 32 );
		var firingPinMaterial = new THREE.MeshLambertMaterial({color: 0xFFFFFF});
		var firingPin = new THREE.Mesh( firingPinGeometry, firingPinMaterial );
		firingPin.position.y = 4;
		firingPin.position.z = 2.5;
		firingPin.rotation.x = Math.PI / 2;

		var muzzleGeometry = new THREE.CircleGeometry( 1.5, 32 );
		var muzzleMaterial = new THREE.MeshLambertMaterial({color: 0x000000});
		var muzzle = new THREE.Mesh( muzzleGeometry, muzzleMaterial );
		muzzle.position.y = -15.1;
		muzzle.rotation.x = Math.PI / 2;

		var wheelTexture = THREE.ImageUtils.loadTexture('assets/cannon-wheel-rim.png');
		var wheelGeometry = new THREE.RingGeometry(4, 5, 32, 32, 0, Math.PI * 2);
		var wheelMaterial = new THREE.MeshLambertMaterial({map: wheelTexture});
		wheelMaterial.side = THREE.DoubleSide;
		var wheel1 = new THREE.Mesh( wheelGeometry, wheelMaterial );
		wheel1.position.x = 2;
		wheel1.position.y = -2;
		wheel1.rotation.y = Math.PI / 2;
		var wheel2 = new THREE.Mesh( wheelGeometry, wheelMaterial );
		wheel2.position.x = -2;
		wheel2.position.y = -2;
		wheel2.rotation.y = Math.PI / 2;
		var wheel3 = new THREE.Mesh( wheelGeometry, wheelMaterial );
		wheel3.position.x = 2.5;
		wheel3.position.y = -2;
		wheel3.rotation.y = Math.PI / 2;
		var wheel4 = new THREE.Mesh( wheelGeometry, wheelMaterial );
		wheel4.position.x = -2.5;
		wheel4.position.y = -2;
		wheel4.rotation.y = Math.PI / 2;

		var wheelCylinder1Geometry = new THREE.CylinderGeometry( 5, 5, 0.5, 32, 32, true );
		var wheelCylinder1 = new THREE.Mesh( wheelCylinder1Geometry, wheelMaterial );
		wheelCylinder1.position.x = 2.25;
		wheelCylinder1.position.y = -2;
		wheelCylinder1.rotation.z = Math.PI / 2;

		var wheelCylinder2 = new THREE.Mesh( wheelCylinder1Geometry, wheelMaterial );
		wheelCylinder2.position.x = -2.25;
		wheelCylinder2.position.y = -2;
		wheelCylinder2.rotation.z = Math.PI / 2;

		var wheelCylinder2Geometry = new THREE.CylinderGeometry( 4, 5, 0.5, 32, 32, true );
		var wheelCylinder1_2 = new THREE.Mesh( wheelCylinder2Geometry, wheelMaterial );
		wheelCylinder1_2.position.x = 2.25;
		wheelCylinder1_2.position.y = -2;
		wheelCylinder1_2.rotation.z = Math.PI / 2;

		var wheelCylinder2_2 = new THREE.Mesh( wheelCylinder2Geometry, wheelMaterial );
		wheelCylinder2_2.position.x = -2.25;
		wheelCylinder2_2.position.y = -2;
		wheelCylinder2_2.rotation.z = Math.PI / 2;

		var axelGeometry = new THREE.RingGeometry(0, 1, 32, 32, 0, Math.PI * 2);
		var axel1 = new THREE.Mesh( axelGeometry, wheelMaterial );
		axel1.position.x = 2;
		axel1.position.y = -2;
		axel1.rotation.y = Math.PI / 2;
		var axel2 = new THREE.Mesh( axelGeometry, wheelMaterial );
		axel2.position.x = -2;
		axel2.position.y = -2;
		axel2.rotation.y = Math.PI / 2;
		var axel3 = new THREE.Mesh( axelGeometry, wheelMaterial );
		axel3.position.x = 2.5;
		axel3.position.y = -2;
		axel3.rotation.y = Math.PI / 2;
		var axel4 = new THREE.Mesh( axelGeometry, wheelMaterial );
		axel4.position.x = -2.5;
		axel4.position.y = -2;
		axel4.rotation.y = Math.PI / 2;

		var axelCylinder1Geometry = new THREE.CylinderGeometry( 1, 1, 0.5, 32, 32, true );
		var axelCylinder1 = new THREE.Mesh( axelCylinder1Geometry, wheelMaterial );
		axelCylinder1.position.x = 2.25;
		axelCylinder1.position.y = -2;
		axelCylinder1.rotation.z = Math.PI / 2;

		var axelCylinder2 = new THREE.Mesh( axelCylinder1Geometry, wheelMaterial );
		axelCylinder2.position.x = -2.25;
		axelCylinder2.position.y = -2;
		axelCylinder2.rotation.z = Math.PI / 2;

		var axelCylinder2Geometry = new THREE.CylinderGeometry( 0, 1, 0.5, 32, 32, true );
		var axelCylinder1_2 = new THREE.Mesh( axelCylinder2Geometry, wheelMaterial );
		axelCylinder1_2.position.x = 2.25;
		axelCylinder1_2.position.y = -2;
		axelCylinder1_2.rotation.z = Math.PI / 2;

		var axelCylinder2_2 = new THREE.Mesh( axelCylinder2Geometry, wheelMaterial );
		axelCylinder2_2.position.x = -2.25;
		axelCylinder2_2.position.y = -2;
		axelCylinder2_2.rotation.z = Math.PI / 2;

		var spokeGeometry = new THREE.CylinderGeometry( 0.25, 0.25, 9.5, 32, 32, false );
		var spoke1 = new THREE.Mesh( spokeGeometry, wheelMaterial );
		spoke1.position.x = -2.25;
		spoke1.position.y = -2;

		var spoke2 = new THREE.Mesh( spokeGeometry, wheelMaterial );
		spoke2.position.x = -2.25;
		spoke2.position.y = -2;
		spoke2.rotation.x = Math.PI / 3;

		var spoke3 = new THREE.Mesh( spokeGeometry, wheelMaterial );
		spoke3.position.x = -2.25;
		spoke3.position.y = -2;
		spoke3.rotation.x = Math.PI / -3;

		var spoke4 = new THREE.Mesh( spokeGeometry, wheelMaterial );
		spoke4.position.x = 2.25;
		spoke4.position.y = -2;

		var spoke5 = new THREE.Mesh( spokeGeometry, wheelMaterial );
		spoke5.position.x = 2.25;
		spoke5.position.y = -2;
		spoke5.rotation.x = Math.PI / 3;

		var spoke6 = new THREE.Mesh( spokeGeometry, wheelMaterial );
		spoke6.position.x = 2.25;
		spoke6.position.y = -2;
		spoke6.rotation.x = Math.PI / -3;

		cannon = new THREE.Object3D();
		cannon.add( can );
		cannon.add( loader );
		cannon.add( firingPin );
		cannon.add( muzzle );
		cannon.add( wheel1 );
		cannon.add( wheel2 );
		cannon.add( wheel3 );
		cannon.add( wheel4 );
		cannon.add( wheelCylinder1 );
		cannon.add( wheelCylinder2 );
		cannon.add( wheelCylinder1_2 );
		cannon.add( wheelCylinder2_2 );
		cannon.add( axel1 );
		cannon.add( axel2 );
		cannon.add( axel3 );
		cannon.add( axel4 );
		cannon.add( axelCylinder1 );
		cannon.add( axelCylinder2 );
		cannon.add( axelCylinder1_2 );
		cannon.add( axelCylinder2_2 );
		cannon.add( spoke1 );
		cannon.add( spoke2 );
		cannon.add( spoke3 );
		cannon.add( spoke4 );
		cannon.add( spoke5 );
		cannon.add( spoke6 );
		
		cannon.rotation.z = Math.PI / 2;
		cannon.position.x -= 144;
		cannon.position.z += 5;
		scene.add( cannon );
	}
	
	function GenerateCannonBall()
	{
		var ballGeometry = new THREE.SphereGeometry( 3 );
		var ballMaterial = Physijs.createMaterial( new THREE.MeshLambertMaterial({color: 'white'}), .95, .95 );
		ball = new Physijs.SphereMesh( ballGeometry, ballMaterial );
		
		ball.position.x = cannon.position.x + 10;
		ball.position.y = cannon.position.y;
		ball.position.z = cannon.position.z;
	}
	
	var targetlist;
	function GenerateTarget()
	{
		targetlist = [];
		
		for( var i=0; i<4; i++ )
		{
			var geo = new THREE.BoxGeometry( 4, 4, 12 );
			var mat = Physijs.createMaterial( new THREE.MeshLambertMaterial({color:'blue'}), .95, .95 );
			var msh = new Physijs.BoxMesh( geo, mat );
			switch( i )
			{
				case 0: msh.position.x = 80; break;
				case 1: msh.position.x = 85; msh.position.y = 5; break;
				case 2: msh.position.x = 90; break;
				case 3: msh.position.x = 85; msh.position.y = -5; break;
			}
			msh.position.z = 6;
			targetlist.push( msh );
			scene.add( msh );
		}
		
	}
	
	function init()
	{
		keyboard = new THREEx.KeyboardState();

		WIDTH = (window.innerWidth) * 0.97;
		HEIGHT = (window.innerHeight) * 0.97;
	
		scene = new Physijs.Scene();
		scene.setGravity(new THREE.Vector3( 0, 0, -30 ));
		scene.addEventListener('update', function() 
		{
			scene.simulate();
		});
		
		camera = new THREE.PerspectiveCamera( 75, WIDTH / HEIGHT, 0.1, 1000 );
		camera.position.x = 0;
		camera.position.y = -100;
		camera.position.z = 250;
		camera.lookAt( scene.position );
		
		renderer = new THREE.WebGLRenderer();
		renderer.setClearColor( 0x000000, 1.0 );
		renderer.setSize( WIDTH, HEIGHT );
		renderer.shadowMapEnabled = true;

		// 1. Drop in ground plane
		GenerateGroundPlane();

		// Generate cannon
		GenerateCannon();
		
		// Generate cannon ball
		GenerateCannonBall();
		
		// Generate target
		GenerateTarget();

        var spotLight = new THREE.DirectionalLight( 0xffffff );
        spotLight.position.set( 0, -30, 150 );
        spotLight.shadowCameraNear = 1;
        spotLight.shadowCameraFar = 1000;
        spotLight.castShadow = true;
		spotLight.intensity = 1.3;
        scene.add(spotLight);
		
		scene.simulate();
		
		document.body.appendChild( renderer.domElement );
		orbControls = new THREE.OrbitControls( camera, renderer.domElement );		
		render();
	}

	function render()
	{
		if( keyboard.pressed("left") )
		{
			cannon.rotation.z += 0.01;
		}
		else if( keyboard.pressed("right") )
		{
			cannon.rotation.z -= 0.01;
		}
		else if( keyboard.pressed("up") )
		{
			cannon.rotation.y -= 0.02;
			if( cannon.rotation.y < -( Math.PI / 5 ) )
			{
				cannon.rotation.y = -( Math.PI / 5 );
			}
		}	
		else if( keyboard.pressed("down") )
		{
			cannon.rotation.y += 0.02;
			if( cannon.rotation.y > 0 )
			{
				cannon.rotation.y = 0;
			}
		}
		else if( !balllaunched && keyboard.pressed("tab") )
		{
			balllaunched = true;
			scene.add( ball );
			ball.applyCentralImpulse( new THREE.Vector3( 8000, -( Math.PI / 2 - cannon.rotation.z ) * 4000, -cannon.rotation.y * 10000 ) );
		}
		else if( balllaunched && keyboard.pressed("escape") )
		{
			balllaunched = false;
			scene.remove( ball );
			GenerateCannonBall();
		}
		
		if( balllaunched )
		{
			if( ball.position.z < -5 )
			{
				balllaunched = false;
				scene.remove( ball );
				GenerateCannonBall();
			}
		}
	
		requestAnimationFrame( render );
		renderer.render( scene, camera );
	}
	
	window.onload = init;

</script>
</body>
</html>
